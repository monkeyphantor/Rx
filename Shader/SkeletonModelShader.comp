#version 450

// Creates a 4x4 translation matrix.
mat4 translate(vec3 pos) {
    mat4 result = mat4(1.0);
    result[3] = vec4(pos, 1.0);
    return result;
}

// Creates a 4x4 scale matrix.
mat4 scale(vec3 scaleVec) {
    mat4 result = mat4(1.0);
    result[0][0] = scaleVec.x;
    result[1][1] = scaleVec.y;
    result[2][2] = scaleVec.z;
    return result;
}

// Converts a quaternion to a 4x4 rotation matrix.
mat4 quatToMat4(vec4 q) {
    // Ensure the quaternion is normalized
    q = normalize(q);
    float x = q.x, y = q.y, z = q.z, w = q.w;

    mat4 result;
    result[0][0] = 1.0 - 2.0 * (y * y + z * z);
    result[0][1] = 2.0 * (x * y + w * z);
    result[0][2] = 2.0 * (x * z - w * y);
    result[0][3] = 0.0;

    result[1][0] = 2.0 * (x * y - w * z);
    result[1][1] = 1.0 - 2.0 * (x * x + z * z);
    result[1][2] = 2.0 * (y * z + w * x);
    result[1][3] = 0.0;

    result[2][0] = 2.0 * (x * z + w * y);
    result[2][1] = 2.0 * (y * z - w * x);
    result[2][2] = 1.0 - 2.0 * (x * x + y * y);
    result[2][3] = 0.0;

    result[3][0] = 0.0;
    result[3][1] = 0.0;
    result[3][2] = 0.0;
    result[3][3] = 1.0;
    return result;
}

// Define a workgroup size. This should be tuned for performance.
// A size of 256 is a good starting point, as it's the max number of bones.
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// A KeyFrame for a single bone, containing its transformation.
struct VkKeyFrame {
    vec4 position;
    vec4 rotation; // Stored as a quaternion
    vec4 scaling;
};

// Structure of a node in the skeleton hierarchy.
struct VkNode {
    ivec4 isBone_parentIndex_boneIndex_padding; // x: isBone, y: parentIndex, z: boneIndex
    mat4 offset; // Inverse bind pose matrix for bones, local transform for other nodes.
};

// The final output transform for a node.
struct NodeTransform {
    mat4 bone;  // Final skinning matrix (global * inverse bind pose)
    mat4 local; // Global transform in model space
};


// Descriptor set bindings for compute shader
// Binding 0: Skeleton structure (nodes)
layout(std430, binding = 0) readonly buffer SkeletonNodes {
    VkNode nodes[];
} skeleton;

// Binding 1: Interpolated keyframes for the current animation pose
layout(std430, binding = 1) readonly buffer KeyFrames {
    VkKeyFrame keyFrames[];
} interpolatedKeyFrames;

// Binding 2: Output buffer for the final node transforms
layout(std430, binding = 2) buffer OutputTransforms {
    NodeTransform transforms[];
} outputTransforms;

layout(push_constant) uniform PushConstants {
    int numberNodes;
} pushConstants;



void main(){
    uint id = gl_WorkGroupID.x;

    mat4 transforms[256];
    mat4 nodeTransforms[256];

    for(int i = 0; i < pushConstants.numberNodes; i++){
        if(skeleton.nodes[i].isBone_parentIndex_boneIndex_padding[0] == 1){
            const VkKeyFrame keyFrame = interpolatedKeyFrames.keyFrames[256*id + skeleton.nodes[i].isBone_parentIndex_boneIndex_padding[2]];
            transforms[i] = translate(keyFrame.position.xyz) * quatToMat4(keyFrame.rotation) * scale(keyFrame.scaling.xyz);
        }else{
            transforms[i] = skeleton.nodes[i].offset;
        }
    }

    nodeTransforms[0] = transforms[0];
    for(int i = 1; i < pushConstants.numberNodes; i++){
        const int parentIndex = skeleton.nodes[i].isBone_parentIndex_boneIndex_padding[1];
        nodeTransforms[i] = nodeTransforms[parentIndex] * transforms[i];
    }

    for(int i = 0; i < pushConstants.numberNodes; i++){
        if(skeleton.nodes[i].isBone_parentIndex_boneIndex_padding[0] == 1){
            outputTransforms.transforms[256* id + i].local = nodeTransforms[i];
            outputTransforms.transforms[256* id + i].bone = nodeTransforms[i] * skeleton.nodes[i].offset;
        }else{
            outputTransforms.transforms[256* id + i].local = nodeTransforms[i];
            outputTransforms.transforms[256* id + i].bone = nodeTransforms[i];
        }
    }

}